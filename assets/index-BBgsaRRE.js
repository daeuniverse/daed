import{i as Q,G as I,f as re,h as je,j as fe,K as ue,k as Me,m as Se,O as ae,n as ie,S as de,T as ye,o as me,p as Oe,q as X,r as $e,s as qe,u as Le,v as We,w as le,x as _e,y as ze,z as De,A as Ge,B as Ue}from"./index-Bvux8vhi.js";const Qe=Object.freeze({major:16,minor:12,patch:0,preReleaseTag:null});function L(e){return typeof e?.then=="function"}function Be(e){let t;return function(n,o,i){t===void 0&&(t=new WeakMap);let a=t.get(n);a===void 0&&(a=new WeakMap,t.set(n,a));let s=a.get(o);s===void 0&&(s=new WeakMap,a.set(o,s));let f=s.get(i);return f===void 0&&(f=e(n,o,i),s.set(i,f)),f}}function be(e){return Promise.all(Object.values(e)).then(t=>{const r=Object.create(null);for(const[n,o]of Object.keys(e).entries())r[o]=t[n];return r})}function Je(e,t,r){let n=r;for(const o of e)n=L(n)?n.then(i=>t(i,o)):t(n,o);return n}function He(e){return e instanceof Error?e:new Ke(e)}class Ke extends Error{constructor(t){super("Unexpected error value: "+Q(t)),this.name="NonErrorThrown",this.thrownValue=t}}function Z(e,t,r){var n;const o=He(e);return Ye(o)?o:new I(o.message,{nodes:(n=o.nodes)!==null&&n!==void 0?n:t,source:o.source,positions:o.positions,path:r,originalError:o})}function Ye(e){return Array.isArray(e.path)}const Xe=Be((e,t,r)=>De(e.schema,e.fragments,e.variableValues,t,r));function Re(e){arguments.length<2||re(!1,"graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");const{schema:t,document:r,variableValues:n,rootValue:o}=e;Ie(t,r,n);const i=Te(e);if(!("schema"in i))return{errors:i};try{const{operation:a}=i,s=Ze(i,a,o);return L(s)?s.then(f=>te(f,i.errors),f=>(i.errors.push(f),te(null,i.errors))):te(s,i.errors)}catch(a){return i.errors.push(a),te(null,i.errors)}}function te(e,t){return t.length===0?{data:e}:{errors:t,data:e}}function Ie(e,t,r){t||re(!1,"Must provide document."),je(e),r==null||fe(r)||re(!1,"Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.")}function Te(e){var t,r,n;const{schema:o,document:i,rootValue:a,contextValue:s,variableValues:f,operationName:y,fieldResolver:v,typeResolver:T,subscribeFieldResolver:d,options:O}=e;let R;const q=Object.create(null);for(const b of i.definitions)switch(b.kind){case ue.OPERATION_DEFINITION:if(y==null){if(R!==void 0)return[new I("Must provide operation name if query contains multiple operations.")];R=b}else((t=b.name)===null||t===void 0?void 0:t.value)===y&&(R=b);break;case ue.FRAGMENT_DEFINITION:q[b.name.value]=b;break}if(!R)return y!=null?[new I(`Unknown operation named "${y}".`)]:[new I("Must provide an operation.")];const B=(r=R.variableDefinitions)!==null&&r!==void 0?r:[],A=Me(o,B,f??{},{maxErrors:(n=O?.maxCoercionErrors)!==null&&n!==void 0?n:50});return A.errors?A.errors:{schema:o,fragments:q,rootValue:a,contextValue:s,operation:R,variableValues:A.coerced,fieldResolver:v??ge,typeResolver:T??nt,subscribeFieldResolver:d??ge,errors:[]}}function Ze(e,t,r){const n=e.schema.getRootType(t.operation);if(n==null)throw new I(`Schema is not configured to execute ${t.operation} operation.`,{nodes:t});const o=Se(e.schema,e.fragments,e.variableValues,n,t.selectionSet),i=void 0;switch(t.operation){case ae.QUERY:return ne(e,n,r,i,o);case ae.MUTATION:return Ce(e,n,r,i,o);case ae.SUBSCRIPTION:return ne(e,n,r,i,o)}}function Ce(e,t,r,n,o){return Je(o.entries(),(i,[a,s])=>{const f=ie(n,a,t.name),y=Ae(e,t,r,s,f);return y===void 0?i:L(y)?y.then(v=>(i[a]=v,i)):(i[a]=y,i)},Object.create(null))}function ne(e,t,r,n,o){const i=Object.create(null);let a=!1;try{for(const[s,f]of o.entries()){const y=ie(n,s,t.name),v=Ae(e,t,r,f,y);v!==void 0&&(i[s]=v,L(v)&&(a=!0))}}catch(s){if(a)return be(i).finally(()=>{throw s});throw s}return a?be(i):i}function Ae(e,t,r,n,o){var i;const a=xe(e.schema,t,n[0]);if(!a)return;const s=a.type,f=(i=a.resolve)!==null&&i!==void 0?i:e.fieldResolver,y=Pe(e,a,n,t,o);try{const v=Oe(a,n[0],e.variableValues),T=e.contextValue,d=f(r,v,T,y);let O;return L(d)?O=d.then(R=>C(e,s,n,y,o,R)):O=C(e,s,n,y,o,d),L(O)?O.then(void 0,R=>{const q=Z(R,n,X(o));return oe(q,s,e)}):O}catch(v){const T=Z(v,n,X(o));return oe(T,s,e)}}function Pe(e,t,r,n,o){return{fieldName:t.name,fieldNodes:r,returnType:t.type,parentType:n,path:o,schema:e.schema,fragments:e.fragments,rootValue:e.rootValue,operation:e.operation,variableValues:e.variableValues}}function oe(e,t,r){if($e(t))throw e;return r.errors.push(e),null}function C(e,t,r,n,o,i){if(i instanceof Error)throw i;if($e(t)){const a=C(e,t.ofType,r,n,o,i);if(a===null)throw new Error(`Cannot return null for non-nullable field ${n.parentType.name}.${n.fieldName}.`);return a}if(i==null)return null;if(qe(t))return et(e,t,r,n,o,i);if(Le(t))return tt(t,i);if(We(t))return rt(e,t,r,n,o,i);if(le(t))return pe(e,t,r,n,o,i);_e(!1,"Cannot complete value of unexpected output type: "+Q(t))}function et(e,t,r,n,o,i){if(!ze(i))throw new I(`Expected Iterable, but did not find one for field "${n.parentType.name}.${n.fieldName}".`);const a=t.ofType;let s=!1;const f=Array.from(i,(y,v)=>{const T=ie(o,v,void 0);try{let d;return L(y)?d=y.then(O=>C(e,a,r,n,T,O)):d=C(e,a,r,n,T,y),L(d)?(s=!0,d.then(void 0,O=>{const R=Z(O,r,X(T));return oe(R,a,e)})):d}catch(d){const O=Z(d,r,X(T));return oe(O,a,e)}});return s?Promise.all(f):f}function tt(e,t){const r=e.serialize(t);if(r==null)throw new Error(`Expected \`${Q(e)}.serialize(${Q(t)})\` to return non-nullable value, returned: ${Q(r)}`);return r}function rt(e,t,r,n,o,i){var a;const s=(a=t.resolveType)!==null&&a!==void 0?a:e.typeResolver,f=e.contextValue,y=s(i,f,n,t);return L(y)?y.then(v=>pe(e,he(v,e,t,r,n,i),r,n,o,i)):pe(e,he(y,e,t,r,n,i),r,n,o,i)}function he(e,t,r,n,o,i){if(e==null)throw new I(`Abstract type "${r.name}" must resolve to an Object type at runtime for field "${o.parentType.name}.${o.fieldName}". Either the "${r.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,n);if(le(e))throw new I("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");if(typeof e!="string")throw new I(`Abstract type "${r.name}" must resolve to an Object type at runtime for field "${o.parentType.name}.${o.fieldName}" with value ${Q(i)}, received "${Q(e)}".`);const a=t.schema.getType(e);if(a==null)throw new I(`Abstract type "${r.name}" was resolved to a type "${e}" that does not exist inside the schema.`,{nodes:n});if(!le(a))throw new I(`Abstract type "${r.name}" was resolved to a non-object type "${e}".`,{nodes:n});if(!t.schema.isSubType(r,a))throw new I(`Runtime Object type "${a.name}" is not a possible type for "${r.name}".`,{nodes:n});return a}function pe(e,t,r,n,o,i){const a=Xe(e,t,r);if(t.isTypeOf){const s=t.isTypeOf(i,e.contextValue,n);if(L(s))return s.then(f=>{if(!f)throw we(t,i,r);return ne(e,t,i,o,a)});if(!s)throw we(t,i,r)}return ne(e,t,i,o,a)}function we(e,t,r){return new I(`Expected value of type "${e.name}" but got: ${Q(t)}.`,{nodes:r})}const nt=function(e,t,r,n){if(fe(e)&&typeof e.__typename=="string")return e.__typename;const o=r.schema.getPossibleTypes(n),i=[];for(let a=0;a<o.length;a++){const s=o[a];if(s.isTypeOf){const f=s.isTypeOf(e,t,r);if(L(f))i[a]=f;else if(f)return i.length&&Promise.allSettled(i).catch(()=>{}),s.name}}if(i.length)return Promise.all(i).then(a=>{for(let s=0;s<a.length;s++)if(a[s])return o[s].name})},ge=function(e,t,r,n){if(fe(e)||typeof e=="function"){const o=e[n.fieldName];return typeof o=="function"?e[n.fieldName](t,r,n):o}};function xe(e,t,r){const n=r.name.value;return n===de.name&&e.getQueryType()===t?de:n===ye.name&&e.getQueryType()===t?ye:n===me.name?me:t.getFields()[n]}function Ve(e){return typeof e?.[Symbol.asyncIterator]=="function"}function ot(e,t){const r=e[Symbol.asyncIterator]();async function n(o){if(o.done)return o;try{return{value:await t(o.value),done:!1}}catch(i){if(typeof r.return=="function")try{await r.return()}catch{}throw i}}return{async next(){return n(await r.next())},async return(){return typeof r.return=="function"?n(await r.return()):{value:void 0,done:!0}},async throw(o){if(typeof r.throw=="function")return n(await r.throw(o));throw o},[Symbol.asyncIterator](){return this}}}async function it(e){arguments.length<2||re(!1,"graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");const t=await st(e);return Ve(t)?ot(t,n=>Re({...e,rootValue:n})):t}function at(e){const t=e[0];return t&&"document"in t?t:{schema:t,document:e[1],rootValue:e[2],contextValue:e[3],variableValues:e[4],operationName:e[5],subscribeFieldResolver:e[6]}}async function st(...e){const t=at(e),{schema:r,document:n,variableValues:o}=t;Ie(r,n,o);const i=Te(t);if(!("schema"in i))return{errors:i};try{const a=await ct(i);if(!Ve(a))throw new Error(`Subscription field must return Async Iterable. Received: ${Q(a)}.`);return a}catch(a){if(a instanceof I)return{errors:[a]};throw a}}async function ct(e){const{schema:t,fragments:r,operation:n,variableValues:o,rootValue:i}=e,a=t.getSubscriptionType();if(a==null)throw new I("Schema is not configured to execute subscription operation.",{nodes:n});const s=Se(t,r,o,a,n.selectionSet),[f,y]=[...s.entries()][0],v=xe(t,a,y[0]);if(!v){const R=y[0].name.value;throw new I(`The subscription field "${R}" is not defined.`,{nodes:y})}const T=ie(void 0,f,a.name),d=Pe(e,v,y,a,T);try{var O;const R=Oe(v,y[0],o),q=e.contextValue,A=await((O=v.subscribe)!==null&&O!==void 0?O:e.subscribeFieldResolver)(i,R,q,d);if(A instanceof Error)throw A;return A}catch(R){throw Z(R,y,X(T))}}function ut(e,t){let r=null;for(const o of e.definitions)if(o.kind===ue.OPERATION_DEFINITION){var n;if(t==null){if(r)return null;r=o}else if(((n=o.name)===null||n===void 0?void 0:n.value)===t)return o}return r}function j(e){return e===null?"null":Array.isArray(e)?"array":typeof e}function z(e){return j(e)==="object"}function lt(e){return typeof Object(e)[Symbol.asyncIterator]=="function"}function se(e){return z(e)&&typeof Object(e)[Symbol.asyncIterator]=="function"&&typeof e.return=="function"}function pt(e){return Array.isArray(e)&&e.length>0&&e.every(t=>"message"in t)}function Ee(e,t){return e.length<124?e:t}const K="graphql-transport-ws",ht="graphql-ws";var P=(e=>(e[e.InternalServerError=4500]="InternalServerError",e[e.InternalClientError=4005]="InternalClientError",e[e.BadRequest=4400]="BadRequest",e[e.BadResponse=4004]="BadResponse",e[e.Unauthorized=4401]="Unauthorized",e[e.Forbidden=4403]="Forbidden",e[e.SubprotocolNotAcceptable=4406]="SubprotocolNotAcceptable",e[e.ConnectionInitialisationTimeout=4408]="ConnectionInitialisationTimeout",e[e.ConnectionAcknowledgementTimeout=4504]="ConnectionAcknowledgementTimeout",e[e.SubscriberAlreadyExists=4409]="SubscriberAlreadyExists",e[e.TooManyInitialisationRequests=4429]="TooManyInitialisationRequests",e))(P||{}),$=(e=>(e.ConnectionInit="connection_init",e.ConnectionAck="connection_ack",e.Ping="ping",e.Pong="pong",e.Subscribe="subscribe",e.Next="next",e.Error="error",e.Complete="complete",e))($||{});function Ne(e){if(!z(e))throw new Error(`Message is expected to be an object, but got ${j(e)}`);if(!e.type)throw new Error("Message is missing the 'type' property");if(typeof e.type!="string")throw new Error(`Message is expects the 'type' property to be a string, but got ${j(e.type)}`);switch(e.type){case"connection_init":case"connection_ack":case"ping":case"pong":{if(e.payload!=null&&!z(e.payload))throw new Error(`"${e.type}" message expects the 'payload' property to be an object or nullish or missing, but got "${e.payload}"`);break}case"subscribe":{if(typeof e.id!="string")throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${j(e.id)}`);if(!e.id)throw new Error(`"${e.type}" message requires a non-empty 'id' property`);if(!z(e.payload))throw new Error(`"${e.type}" message expects the 'payload' property to be an object, but got ${j(e.payload)}`);if(typeof e.payload.query!="string")throw new Error(`"${e.type}" message payload expects the 'query' property to be a string, but got ${j(e.payload.query)}`);if(e.payload.variables!=null&&!z(e.payload.variables))throw new Error(`"${e.type}" message payload expects the 'variables' property to be a an object or nullish or missing, but got ${j(e.payload.variables)}`);if(e.payload.operationName!=null&&j(e.payload.operationName)!=="string")throw new Error(`"${e.type}" message payload expects the 'operationName' property to be a string or nullish or missing, but got ${j(e.payload.operationName)}`);if(e.payload.extensions!=null&&!z(e.payload.extensions))throw new Error(`"${e.type}" message payload expects the 'extensions' property to be a an object or nullish or missing, but got ${j(e.payload.extensions)}`);break}case"next":{if(typeof e.id!="string")throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${j(e.id)}`);if(!e.id)throw new Error(`"${e.type}" message requires a non-empty 'id' property`);if(!z(e.payload))throw new Error(`"${e.type}" message expects the 'payload' property to be an object, but got ${j(e.payload)}`);break}case"error":{if(typeof e.id!="string")throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${j(e.id)}`);if(!e.id)throw new Error(`"${e.type}" message requires a non-empty 'id' property`);if(!pt(e.payload))throw new Error(`"${e.type}" message expects the 'payload' property to be an array of GraphQL errors, but got ${JSON.stringify(e.payload)}`);break}case"complete":{if(typeof e.id!="string")throw new Error(`"${e.type}" message expects the 'id' property to be a string, but got ${j(e.id)}`);if(!e.id)throw new Error(`"${e.type}" message requires a non-empty 'id' property`);break}default:throw new Error(`Invalid message 'type' property "${e.type}"`)}return e}function ke(e,t){return Ne(typeof e=="string"?JSON.parse(e,t):e)}function D(e,t){return Ne(e),JSON.stringify(e,t)}function wt(e){const{url:t,connectionParams:r,lazy:n=!0,onNonLazyError:o=console.error,lazyCloseTimeout:i=0,keepAlive:a=0,disablePong:s,connectionAckWaitTimeout:f=0,retryAttempts:y=5,retryWait:v=async function(p){const c=Math.pow(2,p);await new Promise(l=>setTimeout(l,c*1e3+Math.floor(Math.random()*2700+300)))},shouldRetry:T=ce,on:d,webSocketImpl:O,generateID:R=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,p=>{const c=Math.random()*16|0;return(p=="x"?c:c&3|8).toString(16)})},jsonMessageReplacer:q,jsonMessageReviver:B}=e;let A;if(O){if(!dt(O))throw new Error("Invalid WebSocket implementation provided");A=O}else typeof WebSocket<"u"?A=WebSocket:typeof global<"u"?A=global.WebSocket||global.MozWebSocket:typeof window<"u"&&(A=window.WebSocket||window.MozWebSocket);if(!A)throw new Error("WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`");const b=A,x=(()=>{const u=(()=>{const c={};return{on(l,h){return c[l]=h,()=>{delete c[l]}},emit(l){"id"in l&&c[l.id]?.(l)}}})(),p={connecting:d?.connecting?[d.connecting]:[],opened:d?.opened?[d.opened]:[],connected:d?.connected?[d.connected]:[],ping:d?.ping?[d.ping]:[],pong:d?.pong?[d.pong]:[],message:d?.message?[u.emit,d.message]:[u.emit],closed:d?.closed?[d.closed]:[],error:d?.error?[d.error]:[]};return{onMessage:u.on,on(c,l){const h=p[c];return h.push(l),()=>{h.splice(h.indexOf(l),1)}},emit(c,...l){for(const h of[...p[c]])h(...l)}}})();function m(u){const p=[x.on("error",c=>{p.forEach(l=>l()),u(c)}),x.on("closed",c=>{p.forEach(l=>l()),u(c)})]}let W,M=0,G,w=!1,g=0,U=!1;async function _(){clearTimeout(G);const[u,p]=await(W??(W=new Promise((h,k)=>(async()=>{if(w){if(await v(g),!M)return W=void 0,k({code:1e3,reason:"All Subscriptions Gone"});g++}x.emit("connecting",w);const E=new b(typeof t=="function"?await t():t,K);let J,Y;function ee(){isFinite(a)&&a>0&&(clearTimeout(Y),Y=setTimeout(()=>{E.readyState===b.OPEN&&(E.send(D({type:$.Ping})),x.emit("ping",!1,void 0))},a))}m(F=>{W=void 0,clearTimeout(J),clearTimeout(Y),k(F),F instanceof ve&&(E.close(4499,"Terminated"),E.onerror=null,E.onclose=null)}),E.onerror=F=>x.emit("error",F),E.onclose=F=>x.emit("closed",F),E.onopen=async()=>{try{x.emit("opened",E);const F=typeof r=="function"?await r():r;if(E.readyState!==b.OPEN)return;E.send(D(F?{type:$.ConnectionInit,payload:F}:{type:$.ConnectionInit},q)),isFinite(f)&&f>0&&(J=setTimeout(()=>{E.close(P.ConnectionAcknowledgementTimeout,"Connection acknowledgement timeout")},f)),ee()}catch(F){x.emit("error",F),E.close(P.InternalClientError,Ee(F instanceof Error?F.message:String(F),"Internal client error"))}};let H=!1;E.onmessage=({data:F})=>{try{const N=ke(F,B);if(x.emit("message",N),N.type==="ping"||N.type==="pong"){x.emit(N.type,!0,N.payload),N.type==="pong"?ee():s||(E.send(D(N.payload?{type:$.Pong,payload:N.payload}:{type:$.Pong})),x.emit("pong",!1,N.payload));return}if(H)return;if(N.type!==$.ConnectionAck)throw new Error(`First message cannot be of type ${N.type}`);clearTimeout(J),H=!0,x.emit("connected",E,N.payload,w),w=!1,g=0,h([E,new Promise((mt,Fe)=>m(Fe))])}catch(N){E.onmessage=null,x.emit("error",N),E.close(P.BadResponse,Ee(N instanceof Error?N.message:String(N),"Bad response"))}}})())));u.readyState===b.CLOSING&&await p;let c=()=>{};const l=new Promise(h=>c=h);return[u,c,Promise.race([l.then(()=>{if(!M){const h=()=>u.close(1e3,"Normal Closure");isFinite(i)&&i>0?G=setTimeout(()=>{u.readyState===b.OPEN&&h()},i):h()}}),p])]}function S(u){if(ce(u)&&(ft(u.code)||[P.InternalServerError,P.InternalClientError,P.BadRequest,P.BadResponse,P.Unauthorized,P.SubprotocolNotAcceptable,P.SubscriberAlreadyExists,P.TooManyInitialisationRequests].includes(u.code)))throw u;if(U)return!1;if(ce(u)&&u.code===1e3)return M>0;if(!y||g>=y||!T(u))throw u;return w=!0}n||(async()=>{for(M++;;)try{const[,,u]=await _();await u}catch(u){try{if(!S(u))return}catch(p){return o?.(p)}}})();function V(u,p){const c=R(u);let l=!1,h=!1,k=()=>{M--,l=!0};return(async()=>{for(M++;;)try{const[E,J,Y]=await _();if(l)return J();const ee=x.onMessage(c,H=>{switch(H.type){case $.Next:{p.next(H.payload);return}case $.Error:{h=!0,l=!0,p.error(H.payload),k();return}case $.Complete:{l=!0,k();return}}});E.send(D({id:c,type:$.Subscribe,payload:u},q)),k=()=>{!l&&E.readyState===b.OPEN&&E.send(D({id:c,type:$.Complete},q)),M--,l=!0,J()},await Y.finally(ee);return}catch(E){if(!S(E))return}})().then(()=>{h||p.complete()}).catch(E=>{p.error(E)}),()=>{l||k()}}return{on:x.on,subscribe:V,iterate(u){const p=[],c={done:!1,error:null,resolve:()=>{}},l=V(u,{next(k){p.push(k),c.resolve()},error(k){c.done=!0,c.error=k,c.resolve()},complete(){c.done=!0,c.resolve()}}),h=(async function*(){for(;;){for(p.length||await new Promise(E=>c.resolve=E);p.length;)yield p.shift();if(c.error)throw c.error;if(c.done)return}})();return h.throw=async k=>(c.done||(c.done=!0,c.error=k,c.resolve()),{done:!0,value:void 0}),h.return=async()=>(l(),{done:!0,value:void 0}),h},async dispose(){if(U=!0,W){const[u]=await W;u.close(1e3,"Normal Closure")}},terminate(){W&&x.emit("closed",new ve)}}}class ve extends Error{name="TerminatedCloseEvent";message="4499: Terminated";code=4499;reason="Terminated";wasClean=!1}function ce(e){return z(e)&&"code"in e&&"reason"in e}function ft(e){return[1e3,1001,1006,1005,1012,1013,1014].includes(e)?!1:e>=1e3&&e<=1999}function dt(e){return typeof e=="function"&&"constructor"in e&&"CLOSED"in e&&"CLOSING"in e&&"CONNECTING"in e&&"OPEN"in e}function gt(e){const{schema:t,context:r,roots:n,validate:o,execute:i,subscribe:a,connectionInitWaitTimeout:s=3e3,onConnect:f,onDisconnect:y,onClose:v,onSubscribe:T,onOperation:d,onNext:O,onError:R,onComplete:q,jsonMessageReviver:B,jsonMessageReplacer:A}=e;return{opened(b,x){const m={connectionInitReceived:!1,acknowledged:!1,subscriptions:{},extra:x};if(b.protocol!==K)return b.close(P.SubprotocolNotAcceptable,"Subprotocol not acceptable"),async(M,G)=>{await v?.(m,M,G)};const W=s>0&&isFinite(s)?setTimeout(()=>{m.connectionInitReceived||b.close(P.ConnectionInitialisationTimeout,"Connection initialisation timeout")},s):null;return b.onMessage(async function(G){let w;try{w=ke(G,B)}catch{return b.close(P.BadRequest,"Invalid message received")}switch(w.type){case $.ConnectionInit:{if(m.connectionInitReceived)return b.close(P.TooManyInitialisationRequests,"Too many initialisation requests");m.connectionInitReceived=!0,z(w.payload)&&(m.connectionParams=w.payload);const g=await f?.(m);if(g===!1)return b.close(P.Forbidden,"Forbidden");m.acknowledged=!0,await b.send(D(z(g)?{type:$.ConnectionAck,payload:g}:{type:$.ConnectionAck},A));return}case $.Ping:{if(b.onPing)return await b.onPing(w.payload);await b.send(D(w.payload?{type:$.Pong,payload:w.payload}:{type:$.Pong}));return}case $.Pong:return await b.onPong?.(w.payload);case $.Subscribe:{if(!m.acknowledged)return b.close(P.Unauthorized,"Unauthorized");const{id:g,payload:U}=w;if(g in m.subscriptions)return b.close(P.SubscriberAlreadyExists,`Subscriber for ${g} already exists`);m.subscriptions[g]=null;const _={next:async(S,{id:V,payload:u},p)=>{const{errors:c,...l}=S,h=await O?.(m,V,u,p,S);await b.send(D({id:V,type:$.Next,payload:h||{...l,...c?{errors:c.map(k=>k.toJSON())}:{}}},A))},error:async(S,{id:V,payload:u})=>{const p=await R?.(m,V,u,S);await b.send(D({id:V,type:$.Error,payload:p||S.map(c=>c.toJSON())},A))},complete:async(S,{id:V,payload:u})=>{await q?.(m,V,u),S&&await b.send(D({id:V,type:$.Complete},A))}};try{let S;const V=await T?.(m,w.id,w.payload);if(V){if(yt(V))return g in m.subscriptions?await _.error(V,w):void 0;if(Array.isArray(V))throw new Error("Invalid return value from onSubscribe hook, expected an array of GraphQLError objects");S=V}else{if(!t)throw new Error("The GraphQL schema is not provided");const l={operationName:U.operationName,document:Ge(U.query),variableValues:U.variables};S={...l,schema:typeof t=="function"?await t(m,g,U,l):t};const h=(o??Ue)(S.schema,S.document);if(h.length>0)return g in m.subscriptions?await _.error(h,w):void 0}const u=ut(S.document,S.operationName);if(!u)return g in m.subscriptions?await _.error([new I("Unable to identify operation")],w):void 0;"rootValue"in S||(S.rootValue=n?.[u.operation]),"contextValue"in S||(S.contextValue=typeof r=="function"?await r(m,g,U,S):r);let p;u.operation==="subscription"?p=await(a??it)(S):p=await(i??Re)(S);const c=await d?.(m,g,U,S,p);if(c&&(p=c),lt(p))if(!(g in m.subscriptions))se(p)&&p.return(void 0);else{m.subscriptions[g]=p;try{for await(const l of p)await _.next(l,w,S)}catch(l){const h=l instanceof Error?l:new Error(String(l));await _.error([Qe.major>=16?new I(h.message,{originalError:h}):new I(h.message,null,null,null,null,h)],w)}}else g in m.subscriptions&&await _.next(p,w,S);await _.complete(g in m.subscriptions,w)}finally{delete m.subscriptions[g]}return}case $.Complete:{const g=m.subscriptions[w.id];delete m.subscriptions[w.id],se(g)&&await g.return(void 0);return}default:throw new Error(`Unexpected message of type ${w.type} received`)}}),async(M,G)=>{W&&clearTimeout(W);const w={...m.subscriptions};m.subscriptions={},await Promise.all(Object.values(w).filter(se).map(g=>g.return(void 0))),m.acknowledged&&await y?.(m,M,G),await v?.(m,M,G)}}}}function Et(e){switch(!0){case(e instanceof Set&&e.has(K)):case(Array.isArray(e)&&e.includes(K)):case(typeof e=="string"&&e.split(",").map(t=>t.trim()).includes(K)):return K;default:return!1}}function yt(e){return Array.isArray(e)&&e.length>0&&e.every(t=>t instanceof I)}export{P as CloseCode,ht as DEPRECATED_GRAPHQL_WS_PROTOCOL,K as GRAPHQL_TRANSPORT_WS_PROTOCOL,$ as MessageType,ve as TerminatedCloseEvent,yt as areGraphQLErrors,wt as createClient,Et as handleProtocols,gt as makeServer,ke as parseMessage,D as stringifyMessage,Ne as validateMessage};
